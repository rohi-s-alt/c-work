
Q1. Find Factorial of a number

factorial(0,1).
factorial(N,X):- factorial(N1,X1), N is N1+1,X is X1*N.



?-factorial(5,X).
X=120





Q2. Program to convert temperature from celsius to farenheit and check whether temperature is below freezing point

c_to_f(C,F) :-
F is C * 9 / 5 + 32. 
freezing(F) :-
F =< 32. 

Output:
Queries:
?- c_to_f(100,X). X = 212
Yes
?- freezing(15) .Yes
?- freezing(45). No 

Q3. Monkey Banana Problem Using Prolog
in_room(banana). 
in_room(chair).
in_room(monkey).
push(monkey,chair).
can_climb(monkey, chair). 
grasp(monkey,banana).
eat(monkey,banana).
can_reach(X, Y):-in_room(X),in_room(Y), in_room(Z), push(X,Z), 
can_climb(X, Z), grasp(X,Y), eat(X,Y).


?- can_reach(monkey,banana).



Q4. Medical diagnostic system in prolog
symptom(charlie,fever).
symptom(charlie,rash).
symptom(charlie,headache).
symptom(charlie,runny_nose).
hypothesis(Patient,measles):-symptom(Patient,fever),symptom(Patient,cough),symptom(Patient,conjunctivities),symptom(Patient,runny_nose),symptom(Patient,rash).

hypothesis(Patient,german_measles):-symptom(Patient,fever),symptom(Patient,headache),symptom(Patient,runny_nose),symptom(Patient,rash).

hypothesis(Patient,flu):-symptom(Patient,fever),symptom(Patient,headache),symptom(Patient,body_ache),symptom(Patient,conjunctivities),symptom(Patient,chills),symptom(Patient,sore_throat),symptom(Patient,cough),symptom(Patient,runny_nose).

hypothesis(Patient,common_cold):-symptom(Patient,headache),symptom(Patient,sneezing),symptom(Patient,sore_throat),symptom(Patient,chills),symptom(Patient,runny_nose).hypothesis(Patient,mumps):-symptom(Patient,fever),symptom(Patient,swollen_glands).

hypothesis(Patient,chicken_pox):-symptom(Patient,fever),symptom(Patient,rash),symptom(Patient,body_ache),symptom(Patient,chills).hypothesis(Patient,whooping_cough):-symptom(Patient,cough),symptom(Patient,sneezing),symptom(Patient,runny_nose).

OUTPUT :
 hypothesis(Patient,Disease)
Patient=charlie, Disease=german_measles


Q: To solve any real life problem using DFS

dfs(Current, Goal) :- 
Current = Goal, write('Reached goal!'), nl. 

% Recursive case: Explore neighboring nodes. 

dfs(Current, Goal) :- write('Current node: '), write(Current), nl, neighbor(Current, Next), dfs(Next, Goal). 

% Define a simple neighbor relation
neighbor(A, B) :- B is A + 1. 

Output: ?- dfs(1,10).


Q: Implement local variables and conditional statements using prolog

my_predicate(X, Y) :-
    
LocalVariable = 42,
write(‘LocalVariable=’), write(LocalVariable),nl,
    
(X = 1 ->   Y = 'X is 1' ; 
X = 2 ->  Y = 'X is 2‘;          
        Y = 'X is neither 1 nor 2'
    ).

?- my_predicate(1,    Y).


Q: - Define a predicate to solve the Tower of Hanoi problem.

hanoi(N) :-
    move(N, left, middle, right).

% Define the base case for moving 0 disks (no action needed).
move(0, _, _, _) :- !.

% Define the recursive case for moving N disks.
move(N, A, B, C) :-
    N > 0,
    M is N - 1,
    move(M, A, C, B),           % Move the top N-1 disks from A to B
    display_move(N, A, C),      % Display the move of the Nth disk
    move(M, B, A, C).           % Move the N-1 disks from B to C

% Define a predicate to display the move of a disk.
display_move(Disk, From, To) :-
    format('Move disk ~w from ~w to ~w~n', [Disk, From, To]).

output:  ?- hanoi(3).








AIM: Write a program to solve Water Jug Problem using Prolog.

water_jug(X,Y) :- X>4, Y<3, write('4L jug overflowed'), nl.
water_jug(X,Y) :- X<4, Y>3, write('3L jug overflowed'), nl.
water_jug(X,Y) :- X>4, Y>3, write('Both jugs overflowed'), nl.

water_jug(X,Y) :- 
(X=:=2, Y=:=0, nl, write('4L:2 & 3L:0 (Action: Goal State is reached)'));
(X=:=0, Y=:=0, nl, write('4L:4 & 3L:0 (Action: Fill 4L jug)'), XX is 4, water_jug(XX,Y));
(X=:=0, Y=:=0, nl, write('4L:0 & 3L:3 (Action: Fill 3L jug)'), YY is 3, water_jug(X,YY));
(X=:=1, Y=:=3, nl, write('4L:1 & 3L:0 (Action: Empty 3L jug)'), YY is 0, water_jug(X,YY));
(X=:=3, Y=:=0, nl, write('4L:3 & 3L:3 (Action: Fill 3L jug)'), YY is 3, water_jug(X,YY));
(X=:=4, Y=:=0, nl, write('4L:1 & 3L:3 (Action: Pour water from 4L jug to 3L jug)'), XX is X-3, YY is 3, water_jug(XX,YY));
(X=:=0, Y=:=3, nl, write('4L:3 & 3L:0 (Action: Pour water from 3L jug to 4L jug)'), XX is 3, YY is 0, water_jug(XX,YY));
(X=:=3, Y=:=3, nl, write('4L:4 & 3L:2 (Action: Pour water from 3L jug to 4L jug until 4L jug is full)'), XX is X+1, YY is Y-1, water_jug(XX,YY));
(X=:=1, Y=:=0, nl, write('4L:0 & 3L:1 (Action: Pour water from 4L jug to 3L jug)'), XX is Y, YY is X, water_jug(XX,YY));
(X=:=0, Y=:=1, nl, write('4L:4 & 3L:1 (Action: Fill 4L jug)'), XX is 4, water_jug(XX,Y));
(X=:=4, Y=:=1, nl, write('4L:2 & 3L:3 (Action: Pour water from 4L jug to 3L jug until 4L jug is full)'), XX is X-2, YY is Y+2, water_jug(XX,YY));
(X=:=4, Y=:=2, nl, write('4L:0 & 3L:2 (Action: Empty 4L jug)'), XX is 0, water_jug(XX,Y));
(X=:=2, Y=:=3, nl, write('4L:2 & 3L:0 (Action: Empty 3L jug)'), YY is 0, water_jug(X,YY));
(X=:=0, Y=:=2, nl, write('4L:2 & 3L:0 (Action: Pour water from 3L jug to 4L jug)'), XX is Y, YY is X, water_jug(XX,YY)).





OUTPUT
| ?- water_jug(0,0).

4L:4 & 3L:0 (Action: Fill 4L jug)
4L:1 & 3L:3 (Action: Pour water from 4L jug to 3L jug)
4L:1 & 3L:0 (Action: Empty 3L jug)
4L:0 & 3L:1 (Action: Pour water from 4L jug to 3L jug)
4L:4 & 3L:1 (Action: Fill 4L jug)
4L:2 & 3L:3 (Action: Pour water from 4L jug to 3L jug until 4L jug is full)
4L:2 & 3L:0 (Action: Empty 3L jug)
4L:2 & 3L:0 (Action: Goal State is reached)

true ? ;

4L:0 & 3L:3 (Action: Fill 3L jug)
4L:3 & 3L:0 (Action: Pour water from 3L jug to 4L jug)
4L:3 & 3L:3 (Action: Fill 3L jug)
4L:4 & 3L:2 (Action: Pour water from 3L jug to 4L jug until 4L jug is full)
4L:0 & 3L:2 (Action: Empty 4L jug)
4L:2 & 3L:0 (Action: Pour water from 3L jug to 4L jug)
4L:2 & 3L:0 (Action: Goal State is reached)

true ? 

yes










AIM: Write a program to solve 8-queen problem using Prolog.

% check validity of configuration
valid([],0,_,_).
valid([Q|Qboard],QC,C,R) :- valid(Qboard,CC,C,R),
                            QC is CC + 1,
                            Dc is abs(QC-C),
                            Dr is abs(R-Q),
                            Dr =\= 0,
                            Dc =\= Dr.

% find a valid position
find_valid_position(Q,C,R,R) :- valid(Q,_,C,R).
find_valid_position(Q,C,IR,RR) :- NR is IR + 1,
                                  NR =< 8,
                                  find_valid_position(Q,C,NR,RR).


eight_queen(Q,9,Q).
eight_queen(Q,C,RQ) :- find_valid_position(Q,C,1,X),
                       NQ = [X | Q],
                       NC is C+1,
                       eight_queen(NQ,NC,RQ).

solution(Pos) :- eight_queen([],1,Pos).


| ?- solution(X).
X = [4,2,7,3,6,8,5,1] ? ;
X = [5,2,4,7,3,8,6,1] ? ;
X = [3,5,2,8,6,4,7,1] ?











